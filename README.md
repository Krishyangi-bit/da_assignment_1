Unit 1 Assignment: Recursion and Algorithmic AnalysisStudent Name: RishitaBatch: B.Tech CSE Core (Sec: A)Course: Data Structures Lab (ETCCDS202)1. Factorial and Fibonacci (Naive vs. Memoized)In this task, I implemented recursive functions to calculate Factorials and Fibonacci numbers. I also explored Memoization to optimize recursive calls by storing intermediate results.Key Logic:Factorial: Uses a simple top-down recursion where $n! = n \times (n-1)!$.Fibonacci (Naive): A standard recursive approach. It is intuitive but highly inefficient for larger numbers due to redundant calculations.Fibonacci (Memoized): I used a dictionary (cache) to store previously calculated values. If the function is called for the same $n$ again, it returns the stored result in $O(1)$ time instead of recomputing the entire branch.


Algorithm,Time Complexity,Space Complexity,Reason
Factorial,O(n),O(n),n recursive calls are added to the system stack.
Fibonacci (Naive),O(2n),O(n),"Each call branches into two more, creating an exponential tree."
Fibonacci (Memoized),O(n),O(n),Each value is computed only once; n states are stored in memory.

. Tower of Hanoi ($N=3$)The Tower of Hanoi is a classic puzzle that demonstrates the power of recursive "Divide and Conquer." The goal is to move all disks from a source rod to a target rod using an auxiliary rod, following specific constraints.Recursive Trace for $N=3$:To move 3 disks from Source (A) to Destination (C) using Auxiliary (B):Move disk 1 from A to CMove disk 2 from A to BMove disk 1 from C to BMove disk 3 from A to C (The largest disk reaches the base of the destination)Move disk 1 from B to AMove disk 2 from B to CMove disk 1 from A to CComplexity Note: The total moves required is $2^n - 1$. For $N=3$, that is 7 moves. Therefore, the time complexity is $O(2^n)$.3. Recursive Binary SearchBinary Search is an efficient searching algorithm that works strictly on sorted arrays.How it Works:The algorithm finds the middle element of the array.If target == mid: Return index.If target < mid: Recurse on the left half.If target > mid: Recurse on the right half.Analysis:Since we divide the problem size by half ($n/2$) at every recursive step, the recurrence relation is:$$T(n) = T(n/2) + c$$Time Complexity: $O(\log n)$ — The search space reduces logarithmically.Space Complexity: $O(\log n)$ — Due to the depth of the recursive call stack.ConclusionThis assignment demonstrated that while recursion makes code cleaner and easier to read, it can be computationally expensive. Techniques like Memoization are essential for reducing time complexity from exponential to linear, while Binary Search showcases how "Divide and Conquer" can drastically improve search performance compared to linear methods.
